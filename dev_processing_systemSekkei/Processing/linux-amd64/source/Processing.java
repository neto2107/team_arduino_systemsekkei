/* autogenerated by Processing revision 1289 on 2022-12-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import processing.serial.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Processing extends PApplet {



//定数の宣言
final int height = 720;
final int width = 1280;

final int sideBar_width = 50;

//変数の宣言
Serial port_G;//シリアル「ポート
Serial port2_G;
Serial port3_G;

MyButton button_field;
MyButton button_robot1;
MyButton button_robot2;
MyButton button_robot3;
SideBar sideBar;
PlayField play_field;
Grid grid;

GridContents contents1;
GridContents contents2;
GridContents contents3;

ControlP5 cp;
public void setup() {
  /* size commented out by preprocessor */;
  //インスタンス生成
  sideBar = new SideBar(sideBar_width);
  //controlP5を使用する
  cp = new ControlP5(this);
  play_field = new PlayField();

  //ロボットの生成
  robot1 = new Robot(new Vec2(100, 800), 0);
  robot2 = new Robot(new Vec2(300, 100), 90);
  robot3 = new Robot(new Vec2(300, 1500),-90);
  
  //Serialポートを指定 
  port_G = new Serial(this,"/dev/tty.usbserial-AL01T41S",9600);


  //グリッドの生成
  grid = new Grid();

  //グリッドに描画する要素の作成
  contents1=new GridContents(robot1);
  contents2=new GridContents(robot2);
  contents3=new GridContents(robot3);



  //ボタン関係の描画
  DrawSideButton();
}

public void draw() {
  //サイドバーの描画
  background(242, 242, 242);
  sideBar.barDraw();

  switch(sideBar.getselect_num()  ) {
  case 0:
    play_field .draw();
    break;
  case 1:
    grid.draw();
    contents1.draw();


    break;
  case 2:
    grid.draw();
    contents2.draw();

    break;
  case 3:
    grid.draw();
    contents3.draw();
    break;
  }
}

//イベントが発生した場合の処理
public void controlEvent(ControlEvent theEvent) {
  String label = theEvent.getController().getName();
  switch(label) {
  case "field":
    sideBar.setSelectNum(0);
    break;
  case "robot1":
    sideBar.setSelectNum(1);
    break;
  case "robot2":
    sideBar.setSelectNum(2);
    break;
  case "robot3":
    sideBar.setSelectNum(3);
    break;
  }
}


//ボタンの描画
public void DrawSideButton() {
  //インスタンス生成
  button_field = new MyButton("field", new Vec2(6, 19), new Vec2(40, 32));
  button_robot1 = new MyButton("robot1", new Vec2(2, 71), new Vec2(47, 47));
  button_robot2 = new MyButton("robot2", new Vec2(2, 137), new Vec2(47, 47));
  button_robot3 = new MyButton("robot3", new Vec2(2, 202), new Vec2(47, 47));

  //イメージの読み込み
  button_field.setImg("field.png");
  button_robot1.setImg("robot_button1.png");
  button_robot2.setImg("robot_button2.png");
  button_robot3.setImg("robot_button3.png");
  //ボタンの描画
  button_field.addButton();
  button_robot1.addButton();
  button_robot2.addButton();
  button_robot3.addButton();
}
public class Arrow {
  private int arrowLength = 10; //矢印の長さ
  private float arrowAngle= 0.5f;//矢印の開き具合
  private float angle;
  private Vec2 start_pos;
  private Vec2 end_pos;

  private int[] arrow_color= new int[3];

  Arrow(Vec2 start_pos, Vec2 end_pos, int color_r, int color_g, int color_b) {
    this.start_pos = start_pos;
    this.end_pos = end_pos;
    angle = atan2(end_pos.y - start_pos.y, end_pos.x-start_pos.x);
    arrow_color[0]=color_r;
    arrow_color[1]=color_g;
    arrow_color[2]=color_b;
  }

  public void set_start_pos(Vec2 start_pos) {
    this.start_pos = start_pos;
    update_field();
  }

  public void set_end_pos(Vec2 end_pos) {
    this.end_pos = end_pos;
    update_field();
  }

  private  void update_field() {
    angle = atan2(end_pos.y - start_pos.y, end_pos.x-start_pos.x);
  }

  public void draw() {

    stroke(arrow_color[0], arrow_color[1], arrow_color[2]);
    line(start_pos.x, start_pos.y, end_pos.x, end_pos.y);
    pushMatrix();
    translate(end_pos.x, end_pos.y);
    rotate(angle);
    line(0, 0, -arrowLength*cos(arrowAngle), arrowLength*sin(arrowAngle));
    line(0, 0, -arrowLength*cos(arrowAngle), -arrowLength*sin(arrowAngle));
    popMatrix();
    stroke(0, 0, 0);
  }
}
public abstract class Field extends View {
  final protected Vec2 real_field_size = new Vec2(2500, 1600); //実際のフィールドサイズ(単位はmm) w*h
  protected Vec2 local_field_size = new Vec2(1000, 640);
  ;
  protected Vec2 field_pos= new Vec2(195, 40);

  public Vec2 convert_real_for_local(Vec2 real_pos) {
    return new Vec2(map(real_pos.x, 0, real_field_size.x, 0, local_field_size.x), map(real_pos.y, 0, real_field_size.y, 0, local_field_size.y));
  }
  protected Vec2 convertDrawPos(Vec2 local_pos) {
    return field_pos.getAdd(local_pos);
  }

  protected abstract void draw();
}

public abstract class View {
  protected Vec2 view_size = new Vec2(width-sideBar_width, height);
  protected Vec2 view_point = new Vec2(sideBar_width, 0);
}
//グリッドの左上の位置
public float[] ancerPointListx = new float[6];
public float[] ancerPointListy = new float[6];
//グリッドのサイズ
public float[][] gridSize = new float [6][2];

public class Grid extends View {
  private final int[] grid_row={4, 2} ;

  public Grid() {
    Vec2 ancerPoint = convertDrawPos(new Vec2(0, 0));
    for (int i=0; i<grid_row[0]; i++) {
      print(i);
      ancerPointListx[i] =ancerPoint.x + ( view_size.x   /grid_row[0] ) * i;
      ancerPointListy[i]  =0;
      gridSize[i][0] =  view_size.x   /grid_row[0];
      gridSize[i][1] = view_size.y  / 2;
    }
    for (int j = grid_row[0]; j<grid_row[1]+grid_row[0]; j++) {
      ancerPointListx[j] =ancerPoint.x + ( view_size.x   /grid_row[1] ) * (j-grid_row[0]);
      ancerPointListy[j]  =view_size.y / 2;
            gridSize[j][0] =  view_size.x   /grid_row[1];
      gridSize[j][1] = view_size.y  / 2;
    }
  }
  protected Vec2 convertDrawPos(Vec2 local_pos) {
    return view_point.getAdd(local_pos);
  }



  public void draw() {

    for (int i=0; i<4; i++) {
      stroke(0, 0, 0);
      fill(242, 242, 242);
      rect(ancerPointListx[i], ancerPointListy[i], gridSize[i][0], gridSize[i][1]);
    }
    for (int i = 4; i<6; i++) {
      rect(ancerPointListx[i], ancerPointListy[i], gridSize[i][0], gridSize[i][1]);
    }
  }
}
public class GridContents extends Grid {
  protected Vec2[] ancerPoint;    //それぞれのグリッドの左上の地点
  protected Vec2[] size; //それぞれのグリッドのサイズ
  protected Vec2[] centerPoint; //それぞれのグリッドの中心
  protected Robot robot; //ロボットのインスタンス
  private PImage compasImg; //コンパスのイメージ
  private PImage needleImg; //針のいめーj
  
  private graphMonitor graph,graph2; //グラフのインスタンス

  int c1 = color(1, 61, 255, 70); //超音波センサーセンシング中の色

  GridContents(Robot robot) {
    ancerPoint = new Vec2[6];
    size = new Vec2[6];
    centerPoint = new Vec2[6];
    //それぞれのグリッドの左上
    for (int i = 0; i < 6; i++) {
      ancerPoint[i] = new Vec2(ancerPointListx[i], ancerPointListy[i]);
      size[i] = new Vec2(gridSize[i][0], gridSize[i][1]);
      centerPoint[i] = ancerPoint[i].getAdd(new Vec2(size[i].x /2, size[i].y/2));
    }
    //描画に必要なロボットの情報
    this.robot=robot;
    
    //グラフ描画のための初期化
    graph = new graphMonitor("Acceleration Sensor",-250,-150,500,300);
    graph2 = new graphMonitor("Speed Sensor",-250,-150,500,300);

    //使用する画像の読み込み
    compasImg = loadImage("compas1.png");
    needleImg = loadImage("needle.png");
  }

  public void draw() {
    this.DrawUltrasonicSensor();
    this.drawColorSensor();
    this.drawGeomagneticSensor();
    this.drawAccelSensor();
    this.drawSpeedSensor();
  }

  //pushMatrix();
  //translate(centerPoint.x,centerPoint.y);
  ////ここに描画処理を記述
  //ellipse(0,0,30,30);
  //popMatrix();


  //超音波センサーの描画
  private void DrawUltrasonicSensor() {
    pushMatrix();
    translate(centerPoint[0].x, centerPoint[0].y);
    //ここに描画処理を記述

    //タイトルを描画
    fill(0, 0, 0);
    textSize(30);
    text ("ultrasonic sensor", -110, -150, 500, 200);

    //ロボットを描画
    pushMatrix();
    translate(0, 100);
    //外円を描画
    fill(255, 255, 255);
    ellipse(0, 0, 40, 40);
    //内円を描画
    fill(255, 255, 255);
    ellipse(0, 0, 30, 30);
    //機体番号を描画
    fill(0, 0, 0);
    textSize(20);
    text (Integer.toString(robot.id), -5, -13, 50, 50);
    popMatrix();

    //センサー範囲を描画
    line(0, 80, 0, -100);
    fill(c1);
    strokeWeight(0);
    triangle(0, 80, -30, -100, 30, -100);
    strokeWeight(1);


    //センサー位置を描画
    int censorDir = robot.getUltrasonicSensingDistance();
    if (censorDir >0) {
      fill(255, 0, 0);
      float drawpos = map(censorDir, 0, 300, 80, -100);
      ellipse(0, drawpos, 10, 10);
      //距離を描画
      fill(0, 0, 0);
      textSize(30);
      text (Integer.toString(censorDir) + "mm", -50, 130, 200, 100);
    } else {
      fill(0, 0, 0);
      textSize(30);
      text ( "Not  detected", -90, 130, 200, 100);
    }

    popMatrix();
  }

  //カラーセンサーの描画
  private void drawColorSensor() {
    pushMatrix();
    pushStyle();
    translate(centerPoint[1].x, centerPoint[1].y);
    //タイトルを描画
    fill(0, 0, 0);
    textSize(30);
    text ("Color Sensor", -80, -150, 500, 200);


    //色の表示部分を描画
    int sensored_color = robot.getColorSensorValue();
    fill(sensored_color);
    ellipse(0, 25, 200, 200);

    //色判定部分の描画
    int judge = robot.getColorSenserJudged();
    fill(0, 0, 0);
    textSize(50);
    switch(judge) {
    case 0://判定値が黒なら
      text ("Black", -55, -5, 150, 100);
      break;
    case 1: //判定値が白なら
      text ("White", -55, -5, 150, 100);
      break;
    case 2:
      text ("Red", -55, -5, 150, 100);
      break;
    case 3:
      text("Blue", -55, -5, 150, 100);
      break;
    }
    popStyle();
    popMatrix();
  }

  //地磁気センサーの描画
  private void drawGeomagneticSensor() {
    pushMatrix();
    pushStyle();
    translate(centerPoint[2].x, centerPoint[2].y);
    fill(0, 0, 0);
    textSize(30);
    text ("GeomagneticSensor", -130, -150, 500, 200);

    image(compasImg, -125, -100, 250, 250);
    pushMatrix();
    translate(0, 20);
    imageMode(CENTER);
    rotate(robot.getAngle());
    image(needleImg, 0, 0, 93, 150);
    popMatrix();

    fill(0, 0, 0);
    textSize(30);
    text (Integer.toString((int )Utils.rad_to_deg(robot.getAngle())) + "°", -20, 140, 200, 100);
    popStyle();
    popMatrix();
  }
  
  //加速度センサーの描画
  private void drawAccelSensor(){
    pushMatrix();
    pushStyle();
    translate(centerPoint[4].x, centerPoint[4].y);
    graph.graphDraw(robot.getAccel());
    popStyle();
    popMatrix();
  }
  
  private void drawSpeedSensor(){
    pushMatrix();
    pushStyle();
    translate(centerPoint[5].x, centerPoint[5].y);
    graph2.graphDraw(robot.getSpeed());
    popStyle();
    popMatrix();
  }
}
//ボタンの生成数
int num = 0;
public class MyButton {
  private int button_id;
  private String button_label;
  private Vec2 point; //描画位置 (左上)
  private Vec2 size; //描画サイズ
  private Button bt;
  private PImage[] buttonImg = new PImage[3];//ボタン画像
  private boolean imgflag=false;

  //コンストラクタ
  MyButton(String label, Vec2 point, Vec2 size) {
    this.button_label =label;
    this.point = new Vec2(point);
    this.size = new Vec2(size);

    //ボタンの生成数を1増やす
    num ++;
    button_id =num;
  }
  //画像セット(非選択時の画像、ホバー時の画像、押し下げ時の画像、)
  public void setImg(String path1, String path2, String path3) {

    buttonImg[0] =  loadImage(path1);
    buttonImg[1] =  loadImage(path2);
    buttonImg[2] =  loadImage(path3);
    imgflag=true;
  }
  //画像をセット（すべて同じ画像）
  public void setImg(String imgPath) {
    for (int i = 0; i<3; i++) {
      buttonImg[i] =  loadImage(imgPath);
    }
    imgflag=true;
  }
  //ボタンを追加
  public void addButton() {
    if (imgflag == true) {
      // ボタンの生成
      bt = cp.addButton(button_label).setPosition(point.x, point.y).setSize((int)size.x, (int)size.y).setImages(buttonImg).updateSize();
    } else {
      bt = cp.addButton(button_label).setPosition(point.x, point.y).setSize((int)size.x, (int)size.y);
    }
  }


  public void setVisible(boolean flag) {
    bt.setVisible(flag);
  }
}
public Robot robot1;
public Robot robot2;
public Robot robot3;

public class PlayField extends Field {

  private Vec4 left_goal_line;
  private Vec4 right_goal_line;
  private Arrow ar;

  PlayField() {


    left_goal_line = new Vec4(field_pos.x, 143, field_pos.x, 143 + 475);
    right_goal_line = new Vec4(field_pos.x + local_field_size.x, 143, field_pos.x + local_field_size.x, 143+475);
    //ロボットのインスタンス生成

    ar = new Arrow(new Vec2(300, 300), new Vec2(400, 400), 0, 0, 255);
  }

  public void draw() {
    strokeWeight(10);
    //フィールドの描画
    fill(255, 255, 255);
    rect(field_pos.x, field_pos.y, local_field_size.x, local_field_size.y, 60);
    //ゴールの描画

    stroke(255, 0, 0);
    line(left_goal_line.x1, left_goal_line.y1, left_goal_line.x2, left_goal_line.y2);
    stroke(0, 0, 255);
    line(right_goal_line.x1, right_goal_line.y1, right_goal_line.x2, right_goal_line.y2);
    stroke(0, 0, 0);
    strokeWeight(1);

    //ロボットの描画
    robot1.draw();
    robot2.draw();
    robot3.draw();
    ar.draw();
  }
}
public int robot_num=1;
public class Robot extends Field {
  private int id; //ロボットの分類id
  private Vec2 real_pos; //ロボットの実際の位置
  private int accel;//ロボットの加速度
  private int speed;//ロボットの速度
  private float angle; //角度 //ラジアン角
  private int ultrasonic_sensing_distance = 0;//センサーの感知した位置(mm) 0は未反応
  private int ultrasonic_sensing_range =300; //リアルでどれだけ遠くのものに反応するか(mm)
  private int c3 = color(255, 255, 255); //カラーセンサーの取得値
  private int colorSenserJudged = 0; //カラーセンサーの読み取り値 (0:白 1:黒 2:赤,3：青)

  private Vec2 local_pos;
  private Vec2 draw_pos;
  private float local_sensing_range;//画面上で、どれだけ遠くのものに反応するか

  int c1 = color(1, 61, 255, 70); //超音波センサーセンシング中の色
  int c2 = color(255, 0, 0, 70);


  Textlabel tl1;
  //コンストラクタ
  Robot(Vec2 real_pos, float degree) {
    this.real_pos = real_pos;
    this.local_pos = this.convert_real_for_local(real_pos);
    println(this.local_pos.x + "," + this.local_pos.y);
    this.draw_pos = this.convertDrawPos(local_pos);
    this.angle = Utils.deg_to_rad(degree);
    this.local_sensing_range = Utils.map(300, 0, 2500, 0, 1000);
    this.accel = 0;
    id=robot_num;
    robot_num++; //idを更新
  }

  //ロボットの向きを表示する


  //ロボットを描画するメソッド
  public void draw() {
    pushMatrix(); //(0,0)を原点とする座標軸をスタックに格納
    translate(draw_pos.x, draw_pos.y); //座標軸をロボットの位置まで移動
    //外円を描画
    fill(c3);
    ellipse(0, 0, 50, 50);
    //内円を描画
    fill(255, 255, 255);
    ellipse(0, 0, 40, 40);
    //機体番号を描画
    fill(0, 0, 0);
    textSize(20);
    text (Integer.toString(id), -5, -13, 50, 50);
    //超音波センサーの位置を描画
    rotate(angle +Utils.deg_to_rad(90));//座標軸を回転させる
    fill(c1);
    arc(0, 0, local_sensing_range, local_sensing_range, Utils.deg_to_rad(-105), Utils.deg_to_rad(-75));
    popMatrix();
  }
  
  public int getId(){
    return id;
  }

  public void setPos(Vec2 real_pos) {
    this.real_pos=real_pos;
    updatePos();
  }
  public Vec2 getRealPos(){
    return this.real_pos;
  }

  //ロボットの角度を更新するセッター(入力がラジアン角)
  public void setAngle(float angle) {
    this.angle = angle;
  }
  
  
  //ロボットの角度を更新するセッター(入力がが度)
  public void set_degree(float degree) {
    this.angle = Utils.deg_to_rad(degree);
  }
  public float getAngle(){
    return this.angle;
  }
  

  public void updatePos() {
    this.local_pos = this.convert_real_for_local(real_pos);
    this.draw_pos = this.convertDrawPos(local_pos);
  }

  //カラーセンサーの取得地をセット
  public void setColorSensorValue(int c) {
    this.c3 = c;
  }
  public int getColorSensorValue(){
    return this.c3;
  }
  
  //カラーセンサーの判定値のゲッターとセッター
  public void setColorSenserJudged(int value){
    if(value >= 0 || value <+ 3){ //値が規定内ならセット
      colorSenserJudged = value;
    }else{
      print("error:ColorSenserJudgedが規定外の値です");
    }
  }
  
  public int  getColorSenserJudged(){
    return this.colorSenserJudged;
  }
  
  
  //超音波センサーの値のセッターとゲッター
  public int getUltrasonicSensingDistance(){
    return ultrasonic_sensing_distance;
  }
  public void setUltrasonicSensingDistance(int distance){
    this.ultrasonic_sensing_distance = distance;
  }
  
  //加速度センサーの値のセッターとゲッター
  public void setAccel(int accel){
    this.accel = accel;
  }
  public int getAccel(){
    return this.accel;
  }
  
  //速度センサーのセッターとゲッター
  public void setSpeed(int speed){
    this.speed = speed;
  }
  
  public int getSpeed(){
    return this.speed;
  }
  
}

class RobotManager {
}
public class RobotSimulator {
  private Robot target;

  RobotSimulator(Robot target) {
    this.target = target;
  }
}
public class SideBar {
  final private int[][] box_pos ={{3, 10, 47, 50}, {3, 71, 47, 50}, {3, 135, 47, 50}, {3, 202, 47, 50}};
  private int barWidth;
  private int select_num = 0;

  SideBar(int barWidth) {
    this.barWidth = barWidth;
  }
  public void barDraw() {
    //サイドバーの描画
    fill(48, 48, 48);
    rect(0, 0, barWidth, height);
    selectedBoxDraw();
  }


  private void selectedBoxDraw() {
    fill(161, 161, 161);

    rect(box_pos[select_num][0], box_pos[select_num][1], box_pos[select_num][2], box_pos[select_num][3], 5, 0, 0, 5);
  }

  public int getselect_num() {
    return select_num;
  }

  //サイドバーのどれが選択されているかをセットするセッター
  //select_numは0~3のintがた
  public void setSelectNum(int select_num) {
    if (select_num>=0&&select_num<=3) {
      this.select_num =select_num;
    } else {
      println("select_numの値が不正です");
    }
  }
}
public static class Utils {
  //数値をある範囲から、別の範囲に変換する
  public static float map (float x, float in_min, float in_max, float out_min, float out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  }

  //ラジアン角から度への変換
  public static float rad_to_deg(float radian) {
    return radian * 180 /PI;
  }
  //度からラジアン角へ変換
  public static float deg_to_rad(float degree) {
    return degree * PI /180;
  }
}

class graphMonitor {
    String TITLE;
    int X_POS, Y_POS;
    int X_LENGTH, Y_LENGTH;
    float [] y1, y2, y3;
    float maxRange;
    graphMonitor(String _TITLE, int _X_POSITION, int _Y_POSITION, int _X_LENGTH, int _Y_LENGTH) {
      TITLE = _TITLE;
      X_POS = _X_POSITION;
      Y_POS = _Y_POSITION;
      X_LENGTH   = _X_LENGTH;
      Y_LENGTH   = _Y_LENGTH;
      y1 = new float[X_LENGTH];
      y2 = new float[X_LENGTH];
      y3 = new float[X_LENGTH];
      for (int i = 0; i < X_LENGTH; i++) {
        y1[i] = 0;
      }
    }

    public void graphDraw(float data) {
      y1[X_LENGTH - 1] = data;
      for (int i = 0; i < X_LENGTH - 1; i++) {
        y1[i] = y1[i + 1];
        y2[i] = y2[i + 1];
        y3[i] = y3[i + 1];
      }
      maxRange = 1;
      for (int i = 0; i < X_LENGTH - 1; i++) {
        maxRange = (abs(y1[i]) > maxRange ? abs(y1[i]) : maxRange);
      }

      pushMatrix();

      translate(X_POS, Y_POS);
      fill(240);
      stroke(130);
      strokeWeight(1);
      rect(0, 0, X_LENGTH, Y_LENGTH);
      line(0, Y_LENGTH / 2, X_LENGTH, Y_LENGTH / 2);

      textSize(25);
      fill(60);
      textAlign(LEFT, BOTTOM);
      text(TITLE, 20, -5);
      textSize(22);
      textAlign(RIGHT);
      text(0, -5, Y_LENGTH / 2 + 7);
      text(nf(maxRange, 0, 1), -5, 18);
      text(nf(-1 * maxRange, 0, 1), -5, Y_LENGTH);

      translate(0, Y_LENGTH / 2);
      scale(1, -1);
      strokeWeight(1);
      for (int i = 0; i < X_LENGTH - 1; i++) {
        stroke(255, 0, 0);
        line(i, y1[i] * (Y_LENGTH / 2) / maxRange, i + 1, y1[i + 1] * (Y_LENGTH / 2) / maxRange);
      }
      popMatrix();
    }
}
public class Vec2 {
  public float x, y;
  //コンストラクタ
  public Vec2(float x, float y) {
    this.x = x;
    this.y = y;
  }

  //ゼロベクトルで定義
  public Vec2() {
    this(0, 0);
  }
  //ベクトルをコピー
  public Vec2(Vec2 v) {
    this(v.x, v.y);
  }
  /**
   * 値をセットします。
   *
   * @param x
   * x値
   * @param y
   * y値
   */
  public void set(float x, float y) {
    this.x = x;
    this.y = y;
  }

  /**
   * 値を0にリセットします。
   */
  public void zero() {
    set(0, 0);
  }

  /**
   * ベクトルを加算します。
   *
   * @param v
   * 加算するベクトル
   * @return 加算されたベクトル
   */
  public Vec2 add(Vec2 v) {
    x += v.x;
    y += v.y;
    return this;
  }

  /**
   * ベクトルを減算します。
   *
   * @param v
   * 減算するベクトル
   * @return 減算されたベクトル
   */
  public Vec2 sub(Vec2 v) {
    x -= v.x;
    y -= v.y;
    return this;
  }

  /**
   * ベクトルを乗算します。
   *
   * @param v
   * 乗算するベクトル
   * @return 乗算されたベクトル
   */
  public Vec2 mul(float f) {
    x *= f;
    y *= f;
    return this;
  }

  /**
   * ベクトルを除算します。
   *
   * @param v
   * 除算するベクトル
   * @return 除算されたベクトル
   */
  public Vec2 div(float f) {
    if (f == 0)
      return this;
    x /= f;
    y /= f;
    return this;
  }

  /**
   * ベクトルを加算した結果を返します。
   *
   * @param v
   * 加算するベクトル
   * @return 加算されたベクトル
   */
  public Vec2 getAdd(Vec2 v) {
    return new Vec2(x + v.x, y + v.y);
  }

  /**
   * ベクトルを減算した結果を返します。
   *
   * @param v
   * 減算するベクトル
   * @return 減算されたベクトル
   */
  public Vec2 getSub(Vec2 v) {
    return new Vec2(x - v.x, y - v.y);
  }

  /**
   * ベクトルを乗算した結果を返します。
   *
   * @param v
   * 乗算するベクトル
   * @return 乗算されたベクトル
   */
  public Vec2 getMul(float f) {
    return new Vec2(x * f, y * f);
  }

  /**
   * ベクトルを除算した結果を返します。
   *
   * @param v
   * 除算するベクトル
   * @return 除算されたベクトル
   */
  public Vec2 getDiv(float f) {
    if (f == 0)
      return this;
    return new Vec2(x / f, y / f);
  }

  /**
   * ベクトルの長さを返します。
   *
   * @return このベクトルの長さ
   */
  public float getLength() {
    return (float) Math.sqrt(x * x + y * y);
  }

  /**
   * ベクトルを正規化します。
   
   * 正規化されたベクトルは getLength() == 1 という条件を見たします。
   
   * ただし非常に長さが短いときや、長さが0のときは正しく正規化されません。
   */
  public void normalize() {
    float length = getLength();
    if (length < 0.0001f)
      length = 1.0f;
    x /= length;
    y /= length;
  }

  /**
   * 正規化されたベクトルを返します。
   *
   * @return 正規化されたベクトル
   * @see #normalize()
   */
  public Vec2 getNormalize() {
    float length = getLength();
    if (length < 0.0001f)
      length = 1.0f;
    return new Vec2(x / length, y / length);
  }

  /**
   * ベクトルを反転させます。
   */
  public void reverse() {
    x *= -1;
    y *= -1;
  }

  /**
   * 反転したベクトルが返されます。
   *
   * @return 反転されたベクトル
   */
  public Vec2 getReverse() {
    return new Vec2(-x, -y);
  }

  /**
   * ベクトルをラジアン角で回転させます。
   
   * 度数からラジアンへの変更は Mathf.toRadians が使えます。
   *
   * @param radian
   * ラジアン単位の角度
   * @see Mathf#toRadians(float degree)
   */
  public void rotate(float radian) {
    float x2 = (float) (-Math.sin(radian) * y + Math.cos(radian) * x);
    float y2 = (float) (Math.cos(radian) * y + Math.sin(radian) * x);
    x = x2;
    y = y2;
  }

  /**
   * ベクトルをラジアン角で回転させた結果を返します。
   
   * 度数からラジアンへの変更は Mathf.toRadians が使えます。
   *
   * @param radian
   * ラジアン単位の角度
   * @return 回転後のベクトル
   * @see Mathf#toRadians(float degree)
   */
  public Vec2 getRotate(float radian) {
    return new Vec2((float) (-Math.sin(radian) * y + Math.cos(radian) * x),
      (float) (Math.cos(radian) * y + Math.sin(radian) * x));
  }

  /**
   * @see Object#clone()
   */
  public Vec2 clone() {
    return new Vec2(x, y);
  }

  /**
   * 二つのベクトルの外積を返します。
   
   * 外積は二つのベクトルによって作られる平行四辺形の面積と等しくなります。
   *
   * @param v
   * 一つ目のベクトル
   * @param v2
   * 二つ目のベクトル
   * @return 外積
   */
  public float cross(Vec2 v, Vec2 v2) {
    return v.x * v2.y - v.y * v2.x;
  }

  /**
   * ベクトルの一つが3Dだと仮定したときに、そのz値を指定して外積のベクトルを返します。
   *
   * @param z
   * z値
   * @param v
   * ベクトル
   * @return 外積
   */
  public Vec2 cross(float z, Vec2 v) {
    return new Vec2(-z * v.y, z * v.x);
  }

  /**
   * ベクトルの一つが3Dだと仮定したときに、そのz値を指定して外積のベクトルを返します。
   *
   * @param v
   * ベクトル
   * @param z
   * z値
   * @return 外積
   */
  public Vec2 cross(Vec2 v, float z) {
    return new Vec2(-z * v.y, z * v.x);
  }

  /**
   * 二つのベクトルの内積を返します。
   *
   * @param v
   * 一つ目のベクトル
   * @param v2
   * 二つ目のベクトル
   * @return 内積
   */
  public float dot(Vec2 v, Vec2 v2) {
    return v.x * v2.x + v.y * v2.y;
  }

  /**
   * 長さの二乗を返します。
   *
   * @return 長さの二乗
   */
  public float getLengthSquare() {
    return x * x + y * y;
  }

  /**
   * @see Object#toString()
   */
  public String toString() {
    return "X=" + x + ", Y=" + y;
  }
}

public class Vec4 {
  float x1, y1, x2, y2;
  //コンストラクタ
  public Vec4(float x1, float y1, float x2, float y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  //ゼロベクトルで定義
  public Vec4() {
    this(0, 0, 0, 0);
  }
  //ベクトルをコピー
  public Vec4(Vec4 v) {
    this(v.x1, v.y1, v.x2, v.y2);
  }
  /**
   * 値をセットします。
   *
   * @param x
   * x値
   * @param y
   * y値
   */
  public void set(float x1, float y1, float x2, float y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  /**
   * 値を0にリセットします。
   */
  public void zero() {
    set(0, 0, 0, 0);
  }
}

int sof_f = 0; //SOFを発見したかどうかのフラグ
int l;//受信バッファ内のデータ数
public void serialEvent(Serial p) {
  l = p.available();//受信バッファないのデータ数を取得
  if (p == port_G) {
    recvManager(p, robot1);
  } else if (p == port2_G) {
    recvManager(p, robot2);
  } else if (p == port3_G) {
    recvManager(p, robot3);
  }
}


public int recvManager(Serial p, Robot robo) {
  while (l>0) {//受信バッファないにデータがある時
    if (sof_f == 0) { // SoF を発見していない場合
      int sof = p.read();
      if (sof == 'C') { // SoF:Start of Frame の検査
        sof_f = 1; // SoF の発見を記録('C'(カラーセンサーの値を受け取り):1
      }
      if (sof == 'G') {
        sof_f = 2;//コンパスセンサーの値を受け取り
      }
      if (sof == 'S') {
        sof_f = 3;//超音波センサーの値受け取り
      }
      if (sof == 'A') {
        sof_f = 4;//超音波センサーの値受け取り
      }
      if (sof == 'N'){
        port_G.write(0xff); //バイトデータを送信(1byte)
        sof_f = 0;
        p.clear();
        l = 0;
      }
      l--;//受信バッファ数を修正
    }

    //カラーセンサーの値受け取り
    if (sof_f == 1) {//データの受信を検知したら
      if (l >= 3) { //受信バッファに到着しているデータ数が2以上なら
        //受信したデータを格納
        int c = recvRGB(p);
        robo.setColorSensorValue(c); //ロボットにカラーセンサーの値をセット

        l-=3; //受信した分を減らす
        println("<-C"); //データ受信タイミング
        port_G.write(0xff); //バイトデータを送信(1byte)
        sof_f=0;
      } else {
        break;
      }
    }
    //コンパスセンサーの値受け取り
    if (sof_f == 2) {
      if (l>=2) {

        robo.set_degree(recvCompass(p)); //角度を取得する

        l-=2; //受信した分を減らす
        println("<-G"); //データ受信タイミング
        port_G.write(0xff); //バイトデータを送信(1byte)
        sof_f=0;
      } else {
        break;
      }
    }
    //超音波センサーの値受け取り
    if (sof_f == 3) {
      if (l>=2) {

        robo.setUltrasonicSensingDistance(recvSonic(p) * 10);

        l-=2; //受信した分を減らす
        println("<-G"); //データ受信タイミング
        port_G.write(0xff); //バイトデータを送信(1byte)
        sof_f=0;
      } else {
        break;
      }
    }
    //超音波センサーの値受け取り
    if (sof_f == 4) {
      if (l>=17) {
        //受信したデータを格納
        int c = recvRGB(p);
        robo.setColorSensorValue(c); //ロボットにカラーセンサーの値をセット
        robo.setColorSenserJudged(recvColorId(p));
        robo.set_degree(recvCompass(p)); //角度を取得する
        robo.setUltrasonicSensingDistance(recvSonic(p) * 10);
        robo.setAccel(recvAccel(p)); //加速度の格納と表示
        robo.setSpeed(recvSpeed(p));
        robo.setPos(recvPos(p));

        l-=16; //受信した分を減らす
        println("<-A"); //データ受信タイミング
        println("x:" + robo.getRealPos().x + "y" + robo.getRealPos().y);
        port_G.write(0xff); //バイトデータを送信(1byte)
        sof_f=0;
      } else {
        break;
      }
    }
  }
  return 0;
}
//コンパスの情報を受信するメソッド
public int recvCompass(Serial p) {
  int compass = recvInt(p);
  return compass;
}

//色を受信するメソッド
public int recvRGB(Serial p) {
  int r = p.read();
  int g = p.read();
  int b = p.read();
  int c = color(r, g, b);
  return c;
}

public int recvColorId(Serial p){
  return (int)p.read();
}

//超音波センサーを受信するメソッド
public int recvSonic(Serial p) {
  return recvInt(p);
}

public int recvSpeed(Serial p) {
  return recvInt(p);
}

public int recvAccel(Serial p) {
  return recvInt(p);
}

public Vec2 recvPos(Serial p) {
  Vec2 pos = new Vec2();
  pos.x = recvInt(p);
  pos.y = recvInt(p);
  return pos;
}

//ArduinoからInt型の値を受信する
public int recvInt(Serial p) {
  int high = p.read();//上位8ビットを読み込む
  int low = p.read();//下位8ビットを読み込む
  int val = (high << 8) + low;//上位8ビットシフトして足すことで、1つの変数に戻す
  if (32767 < val)//負の値かどうかが保存されないので、該当するときは場合分け
    val -=65536;//65536 = 2^16

  return val;//得られたInt型の値を返す
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Processing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
